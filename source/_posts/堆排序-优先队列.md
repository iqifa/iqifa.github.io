---
title: 堆排序-优先队列
date: 2024-09-30 18:33:14
tags:
---

[练习题目](https://leetcode.cn/problems/seat-reservation-manager/description/)

### 堆排序

堆排序内部并不一定有序，但是作为最小堆(最大堆)的根是整个堆最小(最大)的，因此，持续的输入堆根便可以进行有序输出。

另外，堆的内部实际上是个[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232#:~:text=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84)。这里只谈论堆的插入删除和维护。

<font color=green>这里以最小堆为例</font>

#### 堆的插入
数据插入时，整个堆实际上已经维护完毕，所以只需要将数据存到数组末尾，然后与父节点对比，再由父节点与父节点的父节点对比，![Heap_Insert](Heap_Insert.png)

代码如下
```c++
    void push(int n)
	{
        //插入数组尾端
		heap.push_back(n);
		int par = (heap.size() - 1 - 1) / 2;
		int index = heap.size() - 1;
        //循环与父节点对比、交换，直到到达根节点或者大于父节点为止
		while (index > 0 && heap[par] > n)
		{
            //与父节点交换，并把位置移到父节点上
			heap[index] = heap[par];
			index = par;
			par = (par - 1) / 2;
		}
		heap[index] = n;
	}
```
#### 堆删除
删除时因为堆属于完美二叉树的限制，所以不能直接从下到上维护。如下
![Heap_Del_Error](Heap_Del_Error.png)

因此，将末尾元素与根元素交换后，再由上到下对比。
![Heap_Del_Right](Heap_Del_Right.png)
同时，这也可以用来进行固定大小的堆排序，只需要将排序好的元素放在末尾，再将前方的元素维护。
代码：
```c++
void pop() {
    //将末尾元素放在根部
	heap[0] = heap[heap.size() - 1];
	int temp = heap[0];
    //设置数组大小减1
	heap.resize(heap.size() - 1);
	int pre = 0;
    //当节点存在子节点时
	while (pre * 2 + 1 <= (int)heap.size() - 1) {
        //右节点存在时
		if (pre * 2 + 2 < (int)heap.size()) {
            //选择子节点中最大的
			next = heap[pre * 2 + 1] < heap[pre * 2 + 2] ? pre * 2 + 1 : pre * 2 + 2;
		}
		else {
			next = pre * 2 + 1;
		}
        //若子节点小则交换
		if (heap[pre] > heap[next])
		{
			heap[pre] = heap[next];
			pre = next;
			heap[pre] = temp;
		}
		else {
            //若小于子节点则跳出
			break;
		}
	}
}
```
### 优先队列
C++STL库里的优先队列 
```c++
    priority_queue<T> heap;
```
其实现原理也是堆，默认为最大堆。查看优先队列代码可以看到，_Ty为数据类型，_Container为保存数据的结构，而_Pr为比较函数。因此优先队列可以保存自定义数据和使用自定义比较方法。
```c++
template <class _Ty, class _Container = vector<_Ty>,
    class _Pr = less<typename _Container::value_type>>
class priority_queue
    //默认最大堆
    priority_queue<int>heap;
    //最小堆
    priority_queue<int, vector<int>, greater<int>> heap;
//自定义结构
class Node{
public:
	int a;
	bool operator>( Node& node) {
		return a > node.a;
	}
};

struct Cmp {
	constexpr bool operator()( Node& a,  Node& b)
	{
		return a > b;
	}
};
priority_queue<Node, vector<Node>, Cmp> heap;
```