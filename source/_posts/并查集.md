---
title: 并查集
date: 2024-03-02 19:35:03
tags: 算法
---
## 并查集
对于集合而言，分为多个子集合，比如以下方集合为例

    {0，1，2，3，4，5，6}
    可分为
    {0，1，2，3}，{4}，{5，6}
而在表示时则使用数组下标形式，可以理解为文件系统的FAT表,比如，在初始时，各个顶点保存数据如下图

![初始数据](image.png)

在分为子集后如下图

<a id="子集划分后数据">![子集划分后数据](image-1.png)</a>
以森林表示即为以下形式

![alt text](image-2.png)

如此在查找是否属于同一子集时通过查询根节点是否相同即可得到结果。
<font color=yellow>也可以解决无向图(无向树)中是否可以到达的问题[leetcode2368](https://leetcode.cn/problems/reachable-nodes-with-restrictions/)</font>

#### 并查集属性
```c++
    class Union
    {
        int size;//并查集大小
	    vector<int> root;//节点上级
	    vector<int>rank;//节点等级
    }
```


#### 初始化节点数据

```c++
Union(int size) {
		this->size = size;
		root.resize(size);
		rank.resize(size);
		for (int i = 0; i < size; i++)
		{
			root[i] = i;//使得每个节点对应上级均为自身
		}
	}
```
#### 查找根节点
```c++
    int find(int x){

        //若节点的上级节点不为本身则代表并不是最高节点，仍需访问上级节点，直到边界条件。
        while(x!=root[x])
        {
            x=root[x];
        }
        return x;
    }
```
#### 合并节点

当合并时，先查找两个节点的最高级，可以理解为加入某一部门，若本就在一个领导下，无需再合并，而当上级不一样时则需判断级别，如一边等级为4一边等级为1 则不可能让等级一做等级4的上级，因此需要rank来保存各节点的等级。
```c++
   void merge(int x, int y)
	{
		int fx = find(x), fy = find(y);

		if (fx != fy)
		{
			if (rank[fx] < rank[fy])
			{
				root[fx] = fy;
				rank[fy]++;
			}
			else {
				root[fy] = fx;
				rank[fx]++;
			}
		}
	}
```
#### 路径压缩算法
因为保存的数据只有自己上级的信息，每次查找根部节点时都需要逐级查找，比如在公司上班时，只知道自己上级，而不知道老板名字，每次需要时都要询问上级，再通过上级返回老板的信息，而通过路径压缩，在第一次查找之后便将上级信息修改，之后查询老板时，只需要询问上级是否是老板，若不是再由上级去查询。下图红色箭头即为路径压缩后的结果。[未路径压缩数据](#子集划分后数据)

![alt text](image-3.png)
```c++
int find(int x){
    int val=x;
    while(x!=root[x])
    {
        x=root[x];
    }
    root[val]=x;
    return x;
}
```
并查集代码如下
```c++
class Union {
public:
	int size;
	vector<int> root;
	vector<int>rank;
	Union(int size) {
		this->size = size;
		root.resize(size);
		rank.resize(size);
		for (int i = 0; i < size; i++)
		{
			root[i] = i;
		}
	}
	int find(int x)
	{
		//未使用路径压缩算法
		int val = x;
		while (root[val] != val)
		{
			val = root[val];
		}
		return val;
	}
	void merge(int x, int y)
	{
		int fx = find(x), fy = find(y);

		if (fx != fy)
		{
			if (rank[fx] < rank[fy])
			{
				root[fx] = fy;
				rank[fy]++;
			}
			else {
				root[fy] = fx;
				rank[fx]++;
			}
		}
	}
};
```