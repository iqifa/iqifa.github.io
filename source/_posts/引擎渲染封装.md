---
title: 引擎渲染封装
date: 2024-01-04 23:35:57
tags: 引擎
---
## 引擎渲染部分
引擎虽然只用OpenGL实现画面的渲染，但是也应当提供封装接口，之后如果跨图形库也需要，比如支持DX，vulkan等等。

### 顶点数据部分封装
#### GL声明代码
GL声明顶点方式如下

```c++
    unsigned int vao,vbo,ibo;//分别代表顶点数组，顶点缓冲，顶点顺序

    float vertex[]={};//顶点数据
    float indices[]={};//顶点顺序

    glGenVertexArrays(1, &vao);
    glGenBuffers(1, &vbo);
    glGenBuffers(1, &ibo);

    glBindVertexArray(vao);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices,GL_STATIC_DRAW);

    glEnableVertexAttribArray(index);
    glVertexAttribPointer(GLuint index,GLint size,GLenum type,GLboolean normalized,GLsizei stride,const GLvoid * pointer);


    ////Draw()

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_INT, nullptr);
```

整个流程冗长且复杂，一不小心可能就会出现问题所以对上面的代码封装

```c++
    class VertexArrays{
        VertexArray();
        void Bind() const;
        void AddBuffer(const VertexBuffer& vb,const VertexBufferLayout layout);
    }
    class VertexBuffer{
        VertexBuffer(const void* data, unsigned int size);
        void Bind() const;
    }
    class IndexBuffer{
        IndexBuffer(const unsigned int* data, unsigned int count);
        void Bind() const;
    }
```

以及最为关键的顶点布局

```c++
    struct  VertexBufferElement{
        int count;
	    unsigned int type;
    }
    class VertexBufferLayout
    {
        vector<VertexBufferElement> m_Elements;
        unsigned int m_Stride;

        template<typename T>
	    void Push(int count)
	    {
		    static_assert(false);
	    }
    }
    以及在绑定顶点数组和顶点数据时分配数据划分

    void VertexArray::AddBuffer(const VertexBuffer& vb, const VertexBufferLayout layout)
{
	Bind();
	vb.Bind();
	const auto& elements = layout.GetElements();
	unsigned int offset = 0;

	for (unsigned int i=0;i<elements.size();i++)
	{
		const auto& element = elements[i];
		glEnableVertexAttribArray(i);
		glVertexAttribPointer(i, element.count, element.type, element.normalized, layout.GetStride(),(const void*)offset);
		offset += element.count* VertexBufferElement::GetSizeOfType(element.type);
	}
}
```
#### 简化后的渲染流程
```c++
    //以下为渲染一个平面，数据为顶点以及纹理
    float position[] = {
		   100.0f, 100.0f,0.0f,0.0f,
		   200.0f, 100.0f,1.0f,0.0f,
		   200.0f, 200.0f,1.0f,1.0f,
		   100.0f, 200.0f,0.0f,1.0f
		};

		unsigned int indices[] = {
			0,1,2,
			2,3,0
		};

    m_vao = make_unique<VertexArray>();
    m_InderBuffer = make_unique<IndexBuffer>(indices, 6);
    m_VertexBuffer=make_unique<VertexBuffer>(position, 4 * 4 * sizeof(float));
    VertexBufferLayout layout;

	layout.Push<float>(2);
	layout.Push<float>(2);
	m_vao->AddBuffer(*m_VertexBuffer, layout);
```


### Shader封装
#### shader创建和编译部分
对shader封装，如此之后过程中可以使用通过Shader来修改
```c++
    ///GL原编译链接shader 
    //program即为shader ID
    unsigned int program = glCreateProgram();


    //生成且编译vertexshader vs 
    //vertexShader为GLSL的顶点着色器文件
    unsigned int vs = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vs, 1, &vertexShader, nullptr);
    glCompileShader(vs);

    int result;
	glGetShaderiv(vs, GL_COMPILE_STATUS, &result);
    if(result==GL_FALSE)
    {
        int lenth;
	    glGetShaderiv(vs, GL_INFO_LOG_LENGTH, &lenth);
        char* message = new char[lenth];
	    glGetShaderInfoLog(vs, lenth, &lenth, message);
        //处理错误信息
    }
    

    //同理得到fragshader fs

	glAttachShader(program, vs);
	glAttachShader(program, fs);
	glLinkProgram(program);
	glValidateProgram(program);

	glDeleteShader(vs);
	glDeleteShader(fs);
    

封装后

    class Shader{
        Shader(const string& filepath, const string& name);
        unsigned int CompileShader(unsigned int type, const string& source);
	    unsigned int CreateShader(const string& vertexShader, const string& fragmentShader);
        static Ref<Shader>Create(const string& filepath, const string& name);
    }

    using Ref = shared_ptr<T>;
    //之后创建shader只需要

    Ref<Shader> m_shader=Shader::Create(filepath,name);
    //或者
    Shader m_shader=new Shader(filepath, name)

    //渲染部分
    va.Bind();
    ib.Bind();
    shader.Bind();

    //绘制
```
#### shader修改数据部分
```c++
//GL修改数据
    int m_shaderID
    int locatation = glGetUniformLocation(m_shaderID, name.c_str());
    glUniform1i(locatation, value);
//封装
    //每次修改数据都要先调用glGetUniformLocation(),浪费性能，
    //所以使用unorder_map<name,location>保存数据，如此再修改时可以直接调用
    mutable unordered_map<string, int>
    int Shader::GetUniformLocation(const string& name)  const
    {
	    if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end())
		    return m_UniformLocationCache[name];

	    int locatation = glGetUniformLocation(m_RendererID, name.c_str());
	    if (locatation == -1)
		    debuglog(m_Name+"Warning: uniform '" + name + "' doesnt exist!");
	    m_UniformLocationCache[name] = locatation;
	    return locatation;
    }
   void Shader::SetUniform1i(const string& name, int value)const
    {
        Bind();
	    glUniform1i(GetUniformLocation(name), value);
    }
```