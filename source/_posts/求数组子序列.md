---
title: 求数组子序列
date: 2024-03-09 16:05:20
categories: [算法,数组]
---
## 数组的子序列
即一数组的部分元素组成的新序列

对于以下数组

$vector<int>nums={1,3,5}$

其全部子序列为

$[ ],[1],[3],[5],[1,3],[1,5],[3,5],[1,3,5]$

而生成所有子序列，以上述数组为例，共有
$2^3=8$
个子序列，生成方法：

1. 空序列 $[ ]$ 开始
2. 在 $[]$ 后加 1 得到 $[1]$
3. 在 $[1]$ 后加 $3$ 得到 $[1,3]$ ,删除 $[1]$ 末尾元素 $1$,再加下一位元素 $3$ 得到$[3]$
4. 将 $[1,3]$ 和 $[3]$ 重复步骤三操作即可得到全部子序列。

### 栈实现
```c++
    stack<pair<deque<int>,int>> sta;

	sta.push({ {},0 });

	while (!sta.empty())
	{
		auto [vec, index] = sta.top();

		sta.pop();

		
		if (index < nums.size())
		{
            deque<int> add1 = vec;
			add1.push_back(nums[index]);
			sta.push({ add1,index + 1 });
			if (index > 0)
			{
                deque<int> add2 = vec;
				add2.pop_back();
				add2.push_back(nums[index]);
				sta.push({ add2,index + 1 });
			}
		}
	}
```
### 引申问题
[$leetcode2386$][2386]

求解数组的第K大和，本质上通过求得第k小子序列和可得到对应剩余序列和为第K大和。这里使用最小堆的思想，在将数组排序后，每次更新序列和时都是非减的，故此使用最小堆实现，

```c++
    sort(nums.begin(), nums.end());
	using vi = pair<long, int>;
	priority_queue<vi,vector<vi>,greater<vi>>pq;
	
	pq.push({0,0});

	long long ret = 0;
	while (k--)
	{
		auto [val, index] = pq.top();
		pq.pop();
		ret = val;
		cout << val << endl;
		if (index < nums.size())
		{
			pq.push({val+ nums[index],index+1});
			if (index > 0)
			pq.push({ val + nums[index] - nums[index-1],index + 1 });
		}
	}
```
#### 序列中的负数问题

计算序列中负数和为 $total_{sub}$ 并将负数设为绝对值，如此得到 新的 $nums$,所有正数和 $total$,负数和$total_{sub}$。

<font color=Aqua>负数思想</font>

    nums={-1,-2,0,1,2}
    numsabs={0,1,1,2,2}

在计算最小序列和val后，计算 $val+total_{sub}$，比如[],所得结果为$total_{sub}$其所代表意义为包含所有负值，而$[1,1,2]$结果为$4+total_{sub}$代表对应子序列中的负数为$[-1]$

推导
设$val$对应子序列为 $subq_{abs}$,$val+total_{sub}$对应子序列为$subq$,则$subq$为所求对应序列，而$subq_{abs}$中包含拥有的正数元素和不包含的负数元素。



[2386]: https://leetcode.cn/problems/find-the-k-sum-of-an-array/description/